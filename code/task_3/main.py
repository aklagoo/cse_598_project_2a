import utils
import numpy as np
import cv2
import matplotlib
import const
from collections import namedtuple
import math
import os
import statistics
from matplotlib import pyplot as plt


def local_nms(keypoints, radius):
    """Performs non-maxima suppression.

    Args:
        keypoints: List of feature keypoints
        radius: Non-maxima suppression radius

    Returns:
        List of local maxima keypoints
    """
    maximas = []
    _keypoints = keypoints.copy()

    for k in keypoints:
        is_max = True
        for l in _keypoints:
            if math.dist(k.pt, l.pt) <= radius:
                if l.response > k.response:
                    _keypoints.pop(0)
                    is_max = False
                    break
        if is_max:
            maximas.append(k)

    return maximas


def filter_matches(keypoints_l, keypoints_r, matches, fundamental, config_params):
    """Filters matches based on their distance and epipolar error

    Args:
        keypoints_l: Keypoints from the left image
        keypoints_r: Keypoints from the right image
        matches: Matches generated by cv2.BFMatcher
        fundamental: Fundamental matrix
        config_params: Set of constants that configures algorithm parameters

    Returns:
        True matches and keypoints associated with the matches on the left and the right
    """
    # Distance based filtering
    distances = [m.distance for m in matches]
    mean = statistics.mean(distances)
    sd = statistics.stdev(distances)
    dist_matches = [m for m in matches if (mean - sd) < m.distance < (mean + sd)]

    true_matches = []
    true_keypoints_l = []
    true_keypoints_r = []

    # Check epipolar constraints
    for m in dist_matches:
        # Convert points to homogeneous form
        x_l, x_r = np.array(keypoints_l[m.queryIdx].pt + (1,)), np.array(keypoints_r[m.trainIdx].pt + (1,))

        # Calculate error
        error = np.matmul(np.matmul(x_r.T, fundamental), x_l).item()
        if -config_params.error_limit < error < config_params.error_limit:
            true_matches.append(m)
            true_keypoints_l.append(keypoints_l[m.queryIdx])
            true_keypoints_r.append(keypoints_r[m.trainIdx])

    return true_matches, true_keypoints_l, true_keypoints_r


def detect_keypoints(image_l, image_r, config_params):
    """Detect keypoints from a pair of images"""

    # Detect keypoints
    orb = cv2.ORB_create()
    keypoints_l = orb.detect(image_l, None)
    keypoints_r = orb.detect(image_r, None)

    # Suppress local non-maximas
    keypoints_l = local_nms(keypoints_l, config_params.nms_radius)
    keypoints_r = local_nms(keypoints_r, config_params.nms_radius)

    # Generate descriptors
    keypoints_l, descriptors_l = orb.compute(image_l, keypoints_l)
    keypoints_r, descriptors_r = orb.compute(image_r, keypoints_r)

    return keypoints_l, descriptors_l, keypoints_r, descriptors_r


def detect_matches(kpl_max, kpr_max, des_l, des_r, stereo_calibration_params, config_params):
    """Generates matches from keypoints and descriptors"""
    bf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)
    matches = bf.match(des_l, des_r)

    true_matches, true_kpl, true_kpr = filter_matches(kpl_max, kpr_max, matches, stereo_calibration_params.F,
                                                      config_params)

    return true_matches, true_kpl, true_kpr


def triangulate_points(stereo_rect_params, keypoints_l, keypoints_r):
    ptl = np.array([[p.pt] for p in keypoints_l])
    ptr = np.array([[p.pt] for p in keypoints_r])

    points = cv2.triangulatePoints(stereo_rect_params.Pl, stereo_rect_params.Pr, ptl, ptr)
    cartesian_pts = points[:3] / points[3]

    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.scatter(*cartesian_pts)
    plt.show()


if __name__ == '__main__':
    ConfigParams = namedtuple('ConfigParams', "error_limit nms_radius")
    params = ConfigParams(1, 6)

    intr = utils.load_intrinsics()

    img_l, img_r = utils.load_img_pair(3)
    img_l_gray, img_r_gray = cv2.cvtColor(img_l, cv2.COLOR_BGR2GRAY), cv2.cvtColor(img_r, cv2.COLOR_BGR2GRAY)

    # Undistort image
    img_l_gray = cv2.undistort(img_l_gray, intr.cml, intr.dsl, None)
    img_r_gray = cv2.undistort(img_r_gray, intr.cmr, intr.dsr, None)

    st_calib, st_rect = utils.load_st_params()

    kpl, dsl, kpr, dsr = detect_keypoints(img_l_gray, img_r_gray, params)
    pos_matches, pos_kpl, pos_kpr = detect_matches(kpl, kpr, dsl, dsr, st_calib, params)

    kpl_image = cv2.drawKeypoints(img_l_gray, kpl, None)
    cv2.imwrite(os.path.join(const.DIR_OUT, 'task_3\\kpl_img.png'), kpl_image)
    kpr_image = cv2.drawKeypoints(img_r_gray, kpr, None)
    cv2.imwrite(os.path.join(const.DIR_OUT, 'task_3\\kpr_img.png'), kpr_image)

    matched_img = cv2.drawMatches(img_l_gray, kpl, img_r_gray, kpr, pos_matches, None,
                                  flags=cv2.DRAW_MATCHES_FLAGS_NOT_DRAW_SINGLE_POINTS)
    cv2.imwrite(os.path.join(const.DIR_OUT, 'task_3\\match_img.png'), matched_img)

    triangulate_points(st_rect, pos_kpl, pos_kpr)
